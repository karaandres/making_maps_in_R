---
title: "Publication-ready maps in R"
author: "Kara Andres"
date: "<div class = 'slide-date'>`r format(Sys.Date(),format='%B %Y')` <div>"
output: ioslides_presentation
autosize: true
---

```{r setup, include=FALSE}
chooseCRANmirror(graphics=FALSE, ind=1)
knitr::opts_chunk$set(echo = TRUE)
```

## Basics of spatial data {.smaller}

Spatial data can come in 2 formats: vector or raster. Vector data is comprised of vertices and paths that connect to form points, lines, and polygons. "Shapefiles" are one of the most common vector formats you see in spatial data. Rasters, on the other hand, are made of a matrix of grid cells or pixels. For simple maps, you'll most often work with shapefiles (e.g. sampling points, state lines, pond outlines). 
```{r fig.width=5, fig.height=5, fig.align="center", echo=FALSE}
library(png)
library(grid)
img <- readPNG("Maps_presentation_files/vector_raster.png")
grid.raster(img)
```

## Map projections {.smaller}
To view the Earth on our screen, we need to figure out how to represent a 3-D object on a 2-D plane. This can be accomplished by projecting the Earth onto a flat surface. Map projections necessarily involve the loss of some data (area, shape, direction, distance, scale)

<div class="columns-2">
Mercator projection: preserves direction, but distorts size
```{r fig.width=4, fig.height=3,echo=FALSE}
img <- readPNG("Maps_presentation_files/mercator.png")
grid.raster(img)
```

Gall-Peters projection: preserves size, but distorts distance
```{r fig.width=4, fig.height=3,echo=FALSE}
img <- readPNG("Maps_presentation_files/peters.png")
grid.raster(img)
```
</div>

## Map projections, cont. {.smaller}
Important note! The default projection in R is to use a rectangular projection with the aspect ratio chosen so that longitude and latitude scales are equivalent at the center of the picture. Thus, when working with data sources without defined projections, you may have to define the projection. I'll show an example of this later on. 

<div class="columns-2">
```{r fig.width=4, fig.height=3, echo=FALSE}
library(ggplot2)
library(maps)
state <- map_data("state")
ggplot(state, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")
```

```{r fig.width=4, fig.height=3,echo=FALSE}
cali <- state[state$region=="california",] 
ggplot(state[state$region=="california",], aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")
```
</div>

## Some key spatial packages: {.smaller}

```{r, message = FALSE, warning=FALSE}
# load relevant packages

library(dplyr)
library(stringr)
library(ggplot2)
library(ggmap)
library(RColorBrewer)
library(maps) # basic maps: continents, countries, states, and counties
library(mapdata) # higher resolution maps
library(rgdal) # reading, writing, converting between spatial data in dozens of formats
library(maptools) # combinig spatial data
library(mapproj) # projecting spatial data
library(sp) # basic functions for spatial data
library(raster) # working with raster data 
library(grDevices) # 
```

## Making basic maps {.smaller}
Maps can be created in base R or ggplot. The `map` function uses map databases to create maps from vector data. Many arguments in the `map` function are similar to plots in base R. Different databases can have different names, extents, resolution, etc. There's no 'Russia' map in the `worldHires` database, but there is a USSR.

```{r fig.width=4, fig.height=3, fig.align="center"}
# Base maps 
map(database = "world", regions = "Russia", col = "lightblue", fill = TRUE,
    xlim=c(100,190), ylim=c(50,75))
```

## Making basic maps, cont. {.smaller}
You can select multiple regions, colors, and can layer maps from multiple databases. You can also add elements with `points` at any latitude and longitude. Note that y is latitude and x is longitude in maps -- don't get these mixed up! 

```{r fig.width=5, fig.height=4, fig.align="center"}
map(database = "state", regions = c("Florida","Georgia","Alabama"), 
    col = c("pink", "darkorchid", "coral"), fill = TRUE, border = NA)
map("county", regions = c("Florida","Georgia","Alabama"), add = T, col = "white")
disney <- c(28.3852, -81.5639) # latitude/longitude points for Disney world
points(x = disney[2], y = disney[1], pch="*", cex=4, col = "yellow") 
# note the switching of lat/long to work with x/y 
```

## Maps with raster data {.smaller}
R can also call raster data from many databases. Beware: these can take a long time to download and can cause R to crash -- save your workspace before loading! 

```{r maps, message = FALSE, warning=FALSE}

# future climate data -- note temps are degrees C * 10
climate_change <- raster:::getData('CMIP5', var='tmax', res=10, rcp=85, model='AC', year=70)
plot(climate_change$ac85tx701)
```

## Making maps in ggplot {.smaller}
Use `map_data` to turn map data fom the `maps` package into data frame that ggplot can read. A couple quick fixes make this map a little nicer: `coord_map()` gives a localized aspect ratio, `low` and `high` change the color gradient, and `trans` puts population on a log scale.

```{r fig.width=5, fig.height=4, fig.align="center"}
states <- map_data("state") 
x <- read.csv("Maps_presentation_files/state_pop.csv", stringsAsFactors = FALSE)
us_pop <- inner_join(states, x, by = "region")
us_pop$Population<- as.numeric(us_pop$Population)

ggplot(data = us_pop) +
  geom_polygon(aes(x = long, y = lat, fill = Population, group = group), color = "white") + scale_fill_gradient(low = "red", high = "blue", trans = "log10") + 
    coord_map() + theme_bw() + theme(plot.margin=unit(c(-0.30,0,0,0), "null"))
```

## Let's make a map! {.smaller}
I need to create a study area map for my manuscript. I want to show my species localities and all IL streams. I also want to code each watershed within my map in a different color. I have a .csv file with lat/long data for my species localities, as well as a shapefile for IL streams (USGS Watershed Boundary Dataset). I also want to add an outline of the state of IL.
```{r}
localities <- read.csv("Maps_presentation_files/illinois_localities.csv")
head(localities)
```

## Let's make a map, cont. {.smaller}
First, let's check out our streams file using the `readOGR` function to read in spatial data. We can see from the summary that this is a polygon shapefile that is projected in the UTM NAD83 zone 16 projection (more on that later). We can also see that there is an attribute for HUC4; this defines the code for each watershed in the state of Illinois.

```{r, echo=FALSE}
watersheds <- readOGR(dsn = "Maps_presentation_files/Stream_HUC4/stream_HUC4.shp")
summary(watersheds)
```

## Next, let's get a map of IL from the `maps` package
```{r}
illinois <- map("state", regions = "Illinois", fill = TRUE)
```

## Looks great! Now, let's put our streams on the map:
```{r}
map("state", regions = "Illinois")
plot(watersheds, add = TRUE)
```

## What happened? {.smaller}
We just saw that our streams and our state plot out separately, but are not lining up when plotted together. 

- Watersheds are defined by the UTM NAD83 **projected coordinate system**
- Metadata for the US Census Bureau (where the data from the 'state' database comes from) is in the NAD83 **geographic coordinate system**
- Units in a geographic coordinate system are decimal degrees (e.g. lat/longs), while the units in a projected coordinate system are feet/meters. 

```{r}
summary(illinois)
projection(illinois)
```

## Fixing the problem {.smaller}
So, what I need to do is turn the Illinois map object into a spatial polygon object and define the projection using `map2SpatialPolygons`. Then I can project it into the same projected coordinate system as my watersheds data with `spTransform`. 

```{r}
illinois <- map2SpatialPolygons(illinois, IDs=illinois$names, 
                                proj4string=CRS("+proj=longlat +datum=NAD83"))
summary(illinois)
projection(illinois)
```

## Fixing the problem, cont. {.smaller}
Now our Illinois shapefile projection is defined. However, note the x and y are in decimal degrees. Contrast with the summary of our watersheds shapefile:

```{r}
summary(watersheds)
```

## Fixing the problem, cont. {.smaller}
To get the Illinois map into a projected coordinate system, let's first create an object to store the projection information from the watersheds file and then project Illinois into a projected coordinate system:

```{r}
projection(watersheds)
UTMnad83<- CRS("+proj=utm +zone=16 +datum=NAD83 +units=m +no_defs")
illinois_proj<- spTransform(illinois, UTMnad83) # transform to UTMnad83
summary(illinois_proj)
```

## Moment of truth {.smaller}
Now, the x and y for the illinois shapefile are in meters, just like our watersheds file. Plotting them together now results in:  

```{r}
plot(illinois_proj)
plot(watersheds, add = T)
```

## Adding species localities {.smaller}
I have a .csv file with lat/longs for the location of each species collection. Recall that lat/longs are in a geographic coordinate system, and we need to project them into a projected coordinate system so they line up with our watersheds. First, we'll create a spatial object with 'coordinates' function

```{r}
coordinates(localities)<- c("Longitude", "Latitude") # x=long, y=lat !!
summary(localities)
```

## Adding species localities, cont.
```{r}
proj4string(localities) <- CRS("+proj=longlat +datum=NAD83") # define projection
localities_proj<- spTransform(localities, UTMnad83) # transform to UTMnad83
summary(localities_proj)
```

## The final product {.smaller}
Now we have everything in order, and we can plot up our spatial objects! Remember that I need to shade my unique watersheds and individual species in unique colors. This is made easy with palettes in RColorBrewer. 

```{r}
water_pal<- brewer.pal(n = 5, name = "Blues") # for my streams 
species_pal<- brewer.pal(n = 6, name = "Dark2")

plot(illinois_proj, col="gray24") # plot projected illinois shapefile
water_col <- 1
for (i in unique(watersheds$HUC4)){
  plot(watersheds[watersheds$HUC4 == i, ], add=TRUE, 
       border = water_pal[water_col], col = water_pal[water_col]) # plot each watershed in a different color
  water_col<- water_col+1 
}

species_col <- 1 
for (i in unique(localities_proj$Genus_spec)){
  plot(localities_proj[localities_proj$Genus_spec == i, ], add=TRUE, 
       pch = 21, bg = species_pal[species_col], col = "black", cex = 1.3)
  species_col<- species_col+1
}

legend("topright", unique(localities_proj$Genus_spec), pch=21, pt.bg=species_pal, col="black", bty="n", text.font=3)
```

## The final product
```{r, fig.width=8, fig.height=5, fig.align="center", echo=FALSE}
water_pal<- brewer.pal(n = 5, name = "Blues") # for my streams 
species_pal<- brewer.pal(n = 6, name = "Dark2")

plot(illinois_proj, col="gray24") # plot projected illinois shapefile
water_col <- 1
for (i in unique(watersheds$HUC4)){
  plot(watersheds[watersheds$HUC4 == i, ], add=TRUE, 
       border = water_pal[water_col], col = water_pal[water_col]) # plot each watershed in a different color
  water_col<- water_col+1 
}

species_col <- 1 
for (i in unique(localities_proj$Genus_spec)){
  plot(localities_proj[localities_proj$Genus_spec == i, ], add=TRUE, 
       pch = 21, bg = species_pal[species_col], col = "black", cex = 1.3)
  species_col<- species_col+1
}

legend("topright", unique(localities_proj$Genus_spec), pch=21, pt.bg=species_pal, col="black", bty="n", text.font=3)
```

## Another example in ggplot {.smaller}
Let's make another sampling map of sampling locations around a lake using different sampling gears. We have lat/longs of our sampling locations and have downloaded shapefiles of U.S. lakes from ArcGIS. Our map will also include a scale bar and an inset map of the entire U.S.

```{r, message=FALSE, warning=FALSE}
all_sampling_points <- read.csv("Maps_presentation_files/all_sampling_points.csv")
ef_dat <- read.csv("Maps_presentation_files/EF spring std site locations2.csv")
lakes <- readOGR("Maps_presentation_files/ne_10m_lakes") # file path to lake shapefile
lakes <- lakes[complete.cases(lakes$name), ]
great_lakes_map <- subset(lakes, name==c("Lake Ontario","Lake Erie"))
oneida_map <- subset(lakes, name=="Oneida Lake")
```

## Oneida map {.smaller}
First, we'll make the main sampling map. 

```{r,  message=FALSE, warning=FALSE}
mapbox <- c(-76.14, 43.14, -75.7, 43.3) # specify map boundaries
oneida_lake <- get_map(location = mapbox, source = "stamen", 
                       maptype = "terrain", zoom = 13)
# Could pull up google maps if you have a license 
cols <- c(brewer.pal(8, "Dark2"),"#386CB0")

oneida_lake_map <- ggmap(oneida_lake) +
  geom_point(data=all_sampling_points, 
             mapping=aes(x=long, y=lat, color=gear, shape=gear), 
             size=3, stroke = 1.2) +
  scale_color_manual(values=cols[c(4,9,6,3,1)]) +
  scale_shape_manual(values=c(17,5,3,16,6)) +
  geom_line(data=ef_dat, aes(x=long, y=lat, group=Description), 
            color="white", size=0.5) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(), axis.ticks = element_blank(),
        rect = element_blank(), axis.title.y=element_blank(),
        axis.title.x=element_blank()) +
  ggsn::scalebar(location = "bottomleft", x.min = -76.13, x.max = -75.7, 
           y.min = 43.145, y.max = 43.25, 
           dist = 5, dist_unit="km", transform = TRUE, 
           model = "WGS84", height = 0.05, 
           st.dist = 0.05, st.bottom=FALSE)
```

## Oneida map, cont. {.smaller}

```{r, fig.width=4, fig.height=3, message=FALSE, warning=FALSE}
library(cowplot)
region_map <- ggplot() + 
  geom_polygon(data=map_data("state"), 
               aes(x=long, y=lat,group=group), color="white") + 
  geom_polygon(data=great_lakes_map, 
               aes(x=long, y=lat, group=group), 
               color="lightblue", fill="lightblue") + 
  geom_polygon(data=oneida_map, aes(x=long, y=lat, group=group), 
               color="lightblue", fill="lightblue") + 
  coord_cartesian(xlim=c(-79, -70), ylim = c(40.05, 45.5)) +
  geom_rect(aes(xmin=-76.2, xmax=-75.67, ymin=43.05, ymax=43.4),
            fill = "transparent", color = "red", size = 0.5) +
  theme_map() + theme(panel.background = element_rect(fill = "white"))
region_map
```

## Final map {.smaller}
```{r, fig.width=8, fig.height=5, fig.align="center"}
inset_map <- ggdraw() + draw_plot(oneida_lake_map) +
  draw_plot(region_map, x = 0.62, y = 0.6, width = 0.26, height = 0.26)
inset_map
```

## Other resources 
https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html
https://www.molecularecologist.com/2012/09/18/making-maps-with-r/
https://mgimond.github.io/Spatial/mapping-data-in-r.html
https://geocompr.robinlovelace.net/adv-map.html
^ includes a tutorial for animated and interactive maps!

Aaaaaaaand there you have it! #maps. 